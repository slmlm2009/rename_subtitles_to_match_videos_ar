# Story 2.2: Implement Backup and Output File Management

## Status
Draft

## Story

**As a** user,  
**I want** the script to create backups of my original files and generate new merged files safely,  
**so that** I don't lose any data if something goes wrong.

## Acceptance Criteria

1. Before embedding, original video files are renamed to `[Original_Filename].original.mkv`
2. The new merged file is created with the original filename `[Original_Filename].mkv`
3. If a `.original.mkv` file already exists, the script asks for user confirmation before overwriting
4. If the merge operation fails, the original file remains intact with the `.original` suffix
5. Sufficient disk space is checked before starting the merge operation
6. The output filename pattern is configurable via the config file
7. Users can verify successful merges before manually deleting `.original` backup files

## Dev Technical Guidance

### Context from Previous Story

Story 2.1 implemented file discovery and matching:
- `find_matching_files(directory_path)` returns list of (video, subtitle) pairs
- Episode and movie detection patterns working correctly
- Integration test confirmed batch processing works with current implementation

### File Management Strategy

**Backup Workflow:**

```python
# High-level workflow from PRD/Architecture
def process_single_pair(video_file, subtitle_file):
    1. Check disk space (video file size + estimated overhead)
    2. Create backup: rename video.mkv → video.original.mkv
       - Handle collision if .original already exists
    3. Run mkvmerge to create new video.mkv
    4. Verify output file was created successfully
    5. On failure: restore original (video.original.mkv → video.mkv)
```

**Disk Space Check:**
- Required space = video file size × 2 (conservative estimate)
- Use `shutil.disk_usage()` to check available space
- Fail early if insufficient space before any file operations

**Backup Naming:**
- Pattern: `{basename}.original{extension}`
- Example: `Show.S01E01.mkv` → `Show.S01E01.original.mkv`
- Configurable via `config.ini` (future enhancement ready)

**Collision Handling:**
- If `.original.mkv` exists:
  - Display: "Backup file already exists: [filename]. Overwrite? (y/n)"
  - If 'n': Skip this file, continue with remaining files
  - If 'y': Overwrite the existing backup

[Source: docs/prd/epic-2-file-discovery-and-management.md#story-2.2, AC 3,4]

### Configuration Integration

**Config.ini Structure (from existing script):**

```ini
[General]
enable_export = true
language_suffix = ar

[Embedding]
# New section for this story
backup_suffix = original
overwrite_backups = prompt  # Options: prompt, always, never
```

**Implementation:**
- Extend existing `load_configuration()` from Story 1.1
- Add `[Embedding]` section parsing
- Default values: backup_suffix='original', overwrite_backups='prompt'

[Source: docs/architecture/architecture-document-subtitle-renamer-tool-ar-subtitle-embedding-feature.md#component-breakdown, config_loader]

### File Operations

**Windows Path Handling (Critical):**
- Use `pathlib.Path` for all file operations
- Convert to `str()` only when calling subprocess
- Handles spaces and special characters correctly

**File Rename Safety:**
```python
from pathlib import Path

def create_backup(video_file: Path) -> Path:
    """
    Rename video file to .original.mkv backup.
    
    Returns: Path to backup file
    Raises: FileExistsError if backup exists and user declines overwrite
    """
    backup_path = video_file.with_suffix('.original.mkv')
    
    if backup_path.exists():
        # AC 3: Ask for confirmation
        response = input(f"Backup exists: {backup_path.name}. Overwrite? (y/n): ")
        if response.lower() != 'y':
            raise FileExistsError(f"Backup exists, user declined overwrite")
    
    # Atomic rename operation
    video_file.rename(backup_path)
    return backup_path

def restore_backup(backup_path: Path, original_path: Path):
    """Restore original file if merge fails."""
    if backup_path.exists() and not original_path.exists():
        backup_path.rename(original_path)
```

[Source: docs/architecture/architecture-document-subtitle-renamer-tool-ar-subtitle-embedding-feature.md#windows-subprocess-execution-guidelines, pathlib usage]

### Integration with Existing Code

**Modify `embed_subtitle_batch()` from Story 1.3:**

```python
# Current implementation (simplified):
def embed_subtitle_batch(video_subtitle_pairs):
    for video, subtitle in pairs:
        output = video  # Currently overwrites original
        run_mkvmerge(output, video, subtitle)

# New implementation for Story 2.2:
def embed_subtitle_batch(video_subtitle_pairs):
    for video, subtitle in pairs:
        try:
            # NEW: Check disk space
            if not has_sufficient_space(video):
                log_error(f"Insufficient disk space for {video.name}")
                continue
            
            # NEW: Create backup
            backup = create_backup(video)
            
            # Run mkvmerge with original filename as output
            result = run_mkvmerge(video, video, subtitle)
            
            if result.returncode != 0:
                # NEW: Restore on failure
                restore_backup(backup, video)
                log_error(f"Merge failed for {video.name}")
            else:
                log_success(f"Successfully embedded: {video.name}")
                
        except FileExistsError as e:
            log_warning(f"Skipped {video.name}: {e}")
        except Exception as e:
            # Ensure backup restoration on any error
            if 'backup' in locals() and backup.exists():
                restore_backup(backup, video)
            log_error(f"Error processing {video.name}: {e}")
```

[Source: docs/stories/1.3.error-handling-and-validation.md, embed_subtitle_batch function]

### Error Handling Strategy

**Error Types:**
1. **Disk Space Error**: Check before any operations, skip file if insufficient
2. **Backup Collision**: Prompt user, skip if declined
3. **Rename Error**: OS permission issues, log and skip
4. **Merge Failure**: Restore backup, log failure
5. **Restore Error**: Critical - log prominently, manual intervention needed

**Logging:**
- Use existing console output pattern from Story 2.1
- Clear status messages: "Creating backup...", "Embedding subtitles...", "Restored original file"
- Error messages with actionable guidance

[Source: docs/stories/1.3.error-handling-and-validation.md#error-handling-requirements]

### Testing Requirements

**Unit Tests** (add to `test_file_matching.py` or new file):

```python
class TestBackupManagement(unittest.TestCase):
    def test_create_backup_new_file(self):
        """Backup created successfully when none exists"""
        # Create temp video file
        # Call create_backup()
        # Verify .original.mkv exists and original is gone
    
    def test_create_backup_collision_accept(self):
        """Backup overwrites when user confirms"""
        # Mock input() to return 'y'
        # Verify backup is overwritten
    
    def test_create_backup_collision_decline(self):
        """FileExistsError raised when user declines"""
        # Mock input() to return 'n'
        # Verify FileExistsError is raised
    
    def test_restore_backup_on_failure(self):
        """Original file restored when merge fails"""
        # Create backup
        # Simulate merge failure
        # Verify original is restored
    
    def test_disk_space_check_sufficient(self):
        """Processing continues with sufficient space"""
        # Mock disk_usage to return large value
        # Verify has_sufficient_space returns True
    
    def test_disk_space_check_insufficient(self):
        """Processing skips file with insufficient space"""
        # Mock disk_usage to return small value
        # Verify has_sufficient_space returns False
```

**Integration Test Update:**
- Extend `test_batch_processing_with_multiple_files` from Story 1.3
- Verify `.original.mkv` files are created
- Verify new `.mkv` files exist after successful merge
- Test backup restoration on simulated mkvmerge failure

[Source: docs/stories/2.1.file-discovery-and-video-subtitle-matching.md#testing-strategy]

### File Locations

**Files to Modify:**
- `embed_subtitles_to_match_videos_ar.py`:
  - Add `create_backup()` function
  - Add `restore_backup()` function
  - Add `has_sufficient_space()` function
  - Modify `embed_subtitle_batch()` to use backup workflow
  - Update `load_configuration()` to parse `[Embedding]` section

**Files to Create:**
- `test_backup_management.py` (new unit test file)

**Config File:**
- Update `config.ini` with `[Embedding]` section (document in code comments)

[Source: docs/architecture/architecture-document-subtitle-renamer-tool-ar-subtitle-embedding-feature.md#source-tree]

### Dependencies

**Python Modules:**
- `pathlib.Path` - File path operations (already in use)
- `shutil.disk_usage()` - Disk space checking (standard library)
- `os.rename()` or `Path.rename()` - File renaming (already in use)

**External Tools:**
- None (this story only adds file management, mkvmerge already integrated)

[Source: docs/architecture/architecture-document-subtitle-renamer-tool-ar-subtitle-embedding-feature.md#tech-stack]

### Performance Considerations

**Disk Space Check:**
- Check once before processing each file (not before entire batch)
- Minimal overhead (~1ms per check)

**File Rename:**
- Atomic operation on same filesystem
- Nearly instantaneous (<10ms)
- No data copying involved

**Backup Storage:**
- Original video files remain on disk until user manually deletes
- User responsibility to clean up after verification

[Source: Architecture document, modular design pattern]

## Tasks / Subtasks

- [ ] Task 1: Implement Disk Space Checking (AC: 5)
  - [ ] Add `has_sufficient_space(video_file: Path) -> bool` function
  - [ ] Use `shutil.disk_usage()` to get available space
  - [ ] Calculate required space: video file size × 2
  - [ ] Return True if available space > required space
  - [ ] Add unit test: `test_disk_space_check_sufficient`
  - [ ] Add unit test: `test_disk_space_check_insufficient`

- [ ] Task 2: Implement Backup Creation Logic (AC: 1, 3)
  - [ ] Add `create_backup(video_file: Path) -> Path` function
  - [ ] Generate backup path: `{basename}.original{extension}`
  - [ ] Check if backup already exists
  - [ ] If exists: prompt user "Backup exists: [filename]. Overwrite? (y/n)"
  - [ ] If 'n': raise `FileExistsError`
  - [ ] If 'y' or new: rename video file to backup path
  - [ ] Return backup path
  - [ ] Add unit test: `test_create_backup_new_file`
  - [ ] Add unit test: `test_create_backup_collision_accept` (mock input)
  - [ ] Add unit test: `test_create_backup_collision_decline` (mock input)

- [ ] Task 3: Implement Backup Restoration Logic (AC: 4)
  - [ ] Add `restore_backup(backup_path: Path, original_path: Path)` function
  - [ ] Check if backup exists and original doesn't
  - [ ] Rename backup back to original filename
  - [ ] Log restoration action clearly
  - [ ] Add unit test: `test_restore_backup_on_failure`

- [ ] Task 4: Integrate Backup Workflow into Batch Processing (AC: 1, 2, 4)
  - [ ] Modify `embed_subtitle_batch()` to use backup workflow
  - [ ] Before mkvmerge: call `has_sufficient_space()`
  - [ ] If insufficient: log warning, skip file, continue to next
  - [ ] Call `create_backup()` before mkvmerge
  - [ ] Run mkvmerge with original filename as output
  - [ ] On mkvmerge success: log success
  - [ ] On mkvmerge failure: call `restore_backup()`, log error
  - [ ] Handle `FileExistsError` from backup creation gracefully
  - [ ] Update integration test to verify `.original.mkv` files created
  - [ ] Update integration test to verify backup restoration on failure

- [ ] Task 5: Add Configuration Support (AC: 6)
  - [ ] Extend `load_configuration()` to parse `[Embedding]` section
  - [ ] Add config key: `backup_suffix` (default: 'original')
  - [ ] Add config key: `overwrite_backups` (default: 'prompt')
  - [ ] Validate configuration values
  - [ ] Document new config options in code comments
  - [ ] Add unit test for configuration parsing

- [ ] Task 6: Enhance Error Messages and User Guidance (AC: 7)
  - [ ] Update console output messages for backup operations
  - [ ] "Creating backup: [filename].original.mkv"
  - [ ] "Embedding subtitles into: [filename].mkv"
  - [ ] "Success: [filename].mkv created. Original saved as [filename].original.mkv"
  - [ ] "Failure: Merge failed. Original file restored."
  - [ ] "Tip: Verify merged files before manually deleting .original backups"
  - [ ] Update error messages with actionable guidance

- [ ] Task 7: Create Test File and Run All Tests (AC: All)
  - [ ] Create `test_backup_management.py` with all unit tests
  - [ ] Run unit tests: `python -m unittest test_backup_management.py`
  - [ ] Run integration tests: `python -m unittest test_embed_subtitles_to_match_videos_ar.TestBatchProcessingIntegration`
  - [ ] Verify all tests pass
  - [ ] Generate test summary CSV if applicable

## Testing

### Test Strategy

**Unit Testing Focus:**
- Disk space checking logic (sufficient/insufficient cases)
- Backup creation (new file, collision accept, collision decline)
- Backup restoration (success case)
- Configuration parsing ([Embedding] section)

**Integration Testing:**
- End-to-end backup workflow with real temp files
- Verify `.original.mkv` files created
- Verify new `.mkv` files created after successful merge
- Simulate mkvmerge failure and verify backup restoration

**Manual Testing:**
- Test with actual media files in controlled environment
- Verify user prompts display correctly
- Verify manual cleanup of .original files works as expected

### Test Files Location

- Unit tests: `test_backup_management.py`
- Integration tests: extend `test_embed_subtitles_to_match_videos_ar.py`
- Test data: Use `tests/` directory with temp file creation

### Success Criteria

- All unit tests pass (100% coverage of new functions)
- Integration test confirms backup workflow in batch processing
- Manual verification: .original files present, new files embedded correctly
- Error cases handled gracefully (insufficient space, backup collision, merge failure)

## Dev Agent Record

### Agent Model Used
- Model: (to be filled by dev agent)

### Debug Log References
- (to be filled by dev agent)

### Completion Notes
- (to be filled by dev agent)

### File List
- Files Modified: (to be filled by dev agent)
- Files Created: (to be filled by dev agent)

## QA Results

(To be filled by QA agent)

## Change Log

(To be filled by dev agent during implementation)
